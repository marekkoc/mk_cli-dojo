{
  "tasks": [
    {
      "id": 151,
      "command": ["cat"],
      "difficulty": 1,
      "rating": 2,
      "category": "text processing",
      "tags": ["file content", "display", "concatenate"],
      "task": "Display the contents of a file with line numbers",
      "solution": "cat -n filename.txt",
      "explanation": "cat -n filename.txt (concatenate and display file with line numbers). The -n flag adds line numbers to each line of output, making it easier to reference specific lines for debugging or analysis. Useful alternative to 'nl' command.",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Quick file inspection with line numbers for debugging"
    },
    {
      "id": 152,
      "command": ["cat"],
      "difficulty": 2,
      "rating": 3,
      "category": "text processing",
      "tags": ["concatenate", "merge", "files"],
      "task": "Concatenate multiple files into a single output file",
      "solution": "cat file1.txt file2.txt file3.txt > combined.txt",
      "explanation": "cat file1.txt file2.txt file3.txt (concatenate multiple files in order) > combined.txt (redirect combined output to new file). Files are joined sequentially without any separators. Preserves original file order and content.",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Merge log files or combine data files for analysis"
    },
    {
      "id": 153,
      "command": ["cat"],
      "difficulty": 3,
      "rating": 4,
      "category": "text processing",
      "tags": ["here document", "creation", "scripting"],
      "task": "Create a multi-line file using cat with here document",
      "solution": "cat > config.txt << EOF\nserver=localhost\nport=8080\ndebug=true\nEOF",
      "explanation": "cat > config.txt (redirect cat output to file) << EOF (here document delimiter - read until EOF marker) \\nserver=localhost\\nport=8080\\ndebug=true\\nEOF (multi-line content ending with delimiter). Creates files with embedded content in scripts.",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Create configuration files or scripts from command line"
    },
    {
      "id": 154,
      "command": ["cat"],
      "difficulty": 2,
      "rating": 3,
      "category": "text processing",
      "tags": ["whitespace", "tabs", "formatting"],
      "task": "Display file content showing tabs as ^I and line endings",
      "solution": "cat -A filename.txt",
      "explanation": "cat -A filename.txt (show all non-printing characters). Displays tabs as ^I, line endings as $, and other control characters visibly. The -A flag combines -vET options for comprehensive whitespace visualization. Essential for debugging formatting issues.",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Debug formatting issues and invisible characters in text files"
    },
    {
      "id": 155,
      "command": ["touch"],
      "difficulty": 1,
      "rating": 2,
      "category": "file management",
      "tags": ["file creation", "empty file", "new"],
      "task": "Create multiple empty files at once",
      "solution": "touch file1.txt file2.txt file3.txt",
      "explanation": "touch file1.txt file2.txt file3.txt (create multiple empty files in one command). If files don't exist, touch creates them with zero size and current timestamp. If files exist, only timestamps are updated without changing content.",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Quickly create placeholder files for development or testing"
    },
    {
      "id": 156,
      "command": ["touch"],
      "difficulty": 2,
      "rating": 3,
      "category": "file management",
      "tags": ["timestamp", "modification time", "access time"],
      "task": "Update file timestamp to current time without changing content",
      "solution": "touch existing_file.txt",
      "explanation": "touch existing_file.txt (update access and modification times to current time). Does not modify file content, only metadata timestamps. Useful for triggering build systems or backup tools that rely on modification times for change detection.",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Force file modification time update for build systems or backups"
    },
    {
      "id": 157,
      "command": ["touch"],
      "difficulty": 3,
      "rating": 4,
      "category": "file management",
      "tags": ["specific timestamp", "date", "time manipulation"],
      "task": "Create file with specific timestamp from the past",
      "solution": "touch -t 202301011200 old_file.txt",
      "explanation": "touch -t 202301011200 old_file.txt (set specific timestamp using -t flag). Time format is [[CC]YY]MMDDhhmm[.ss] - here 202301011200 means January 1, 2023, 12:00. Creates file with historical timestamp for testing date-based operations.",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Create test files with historical timestamps for testing date-based operations"
    },
    {
      "id": 158,
      "command": ["tail"],
      "difficulty": 1,
      "rating": 2,
      "category": "text processing",
      "tags": ["end of file", "last lines", "monitoring"],
      "task": "Display the last 20 lines of a log file",
      "solution": "tail -n 20 logfile.log",
      "explanation": "tail -n 20 logfile.log (show last 20 lines of file). Default is 10 lines, -n specifies exact number. Useful for checking recent log entries without reading entire file. More efficient than cat for large files when only end matters.",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Check recent entries in log files for debugging"
    },
    {
      "id": 159,
      "command": ["tail"],
      "difficulty": 2,
      "rating": 4,
      "category": "monitoring",
      "tags": ["real-time", "follow", "live monitoring"],
      "task": "Monitor log file in real-time showing new lines as they appear",
      "solution": "tail -f application.log",
      "explanation": "tail -f application.log (follow file as it grows, showing new lines in real-time). The -f flag keeps tail running and displays new content as it's appended. Essential for live log monitoring during application development and troubleshooting.",
      "execution_time": "long-running",
      "requirements": null,
      "warnings": "Press Ctrl+C to stop monitoring",
      "use_case": "Real-time monitoring of application logs during development or troubleshooting"
    },
    {
      "id": 160,
      "command": ["tail", "grep"],
      "difficulty": 3,
      "rating": 4,
      "category": "monitoring",
      "tags": ["filtered monitoring", "error tracking", "real-time"],
      "task": "Monitor log file in real-time and show only error messages",
      "solution": "tail -f app.log | grep -i error",
      "explanation": "tail -f app.log (follow log file in real-time) | grep -i error (filter for lines containing 'error' case-insensitively). Combines real-time monitoring with filtering to show only relevant error messages. Pipeline allows focused monitoring of specific events.",
      "execution_time": "long-running",
      "requirements": null,
      "warnings": null,
      "use_case": "Real-time error monitoring and alerting in production systems"
    },
    {
      "id": 161,
      "command": ["head"],
      "difficulty": 1,
      "rating": 2,
      "category": "text processing",
      "tags": ["beginning of file", "first lines", "preview"],
      "task": "Display the first 15 lines of a large data file",
      "solution": "head -n 15 data.csv",
      "explanation": "head -n 15 data.csv (show first 15 lines of file). Default is 10 lines, -n specifies exact number. Useful for previewing file structure, headers, and sample data before processing large files. More efficient than cat for quick inspection.",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Preview file structure and headers before processing large datasets"
    },
    {
      "id": 162,
      "command": ["head", "tail"],
      "difficulty": 3,
      "rating": 4,
      "category": "text processing",
      "tags": ["extract range", "specific lines", "text extraction"],
      "task": "Extract lines 10-20 from a file using head and tail combination",
      "solution": "head -n 20 file.txt | tail -n 11",
      "explanation": "head -n 20 file.txt (get first 20 lines) | tail -n 11 (from those 20 lines, take the last 11). This extracts lines 10-20 (11 lines total). Pipeline technique for extracting specific line ranges without sed or awk.",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Extract specific line ranges from large files for analysis or debugging"
    }
  ]
}