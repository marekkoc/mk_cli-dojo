{
  "tasks": [
    {
      "id": 218,
      "command": ["date"],
      "difficulty": 1,
      "rating": 2,
      "category": "date operations",
      "tags": ["date", "formatting", "timestamp"],
      "task": "Display current date in various formats for logging and file naming",
      "solution": "echo \"ISO: $(date +%Y-%m-%d)\"; echo \"US: $(date +%m/%d/%Y)\"; echo \"Timestamp: $(date +%Y%m%d_%H%M%S)\"",
      "explanation": "date +%Y-%m-%d (ISO format YYYY-MM-DD) date +%m/%d/%Y (US format MM/DD/YYYY) date +%Y%m%d_%H%M%S (compact timestamp for filenames). Different format strings serve different purposes: ISO for standards compliance, US for regional preferences, compact for file naming.",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Logging systems, file naming conventions, and timestamp standardization"
    },
    {
      "id": 219,
      "command": ["date"],
      "difficulty": 2,
      "rating": 3,
      "category": "date operations",
      "tags": ["date", "calculation", "relative"],
      "task": "Calculate dates relative to current date for backup rotation",
      "solution": "echo \"Today: $(date +%Y-%m-%d)\"; echo \"Yesterday: $(date -d 'yesterday' +%Y-%m-%d)\"; echo \"Last week: $(date -d '7 days ago' +%Y-%m-%d)\"; echo \"Next month: $(date -d '+1 month' +%Y-%m-%d)\"",
      "explanation": "date -d 'yesterday' (calculate yesterday's date) date -d '7 days ago' (date 7 days in the past) date -d '+1 month' (date 1 month in the future). The -d flag accepts natural language expressions for relative date calculations, useful for backup rotation and scheduling.",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Backup rotation policies, log retention, and scheduled task planning"
    },
    {
      "id": 220,
      "command": ["date", "git"],
      "difficulty": 3,
      "rating": 4,
      "category": "version control",
      "tags": ["date", "git", "commit", "automation"],
      "task": "Create git commit with formatted timestamp and automated message",
      "solution": "git add . && git commit -m \"Auto-backup: $(date '+%Y-%m-%d %H:%M:%S') - $(git diff --cached --stat | wc -l) files changed\"",
      "explanation": "git add . (stage all changes) && git commit -m \"Auto-backup: $(date '+%Y-%m-%d %H:%M:%S') (formatted timestamp) - $(git diff --cached --stat | wc -l) files changed\" (count changed files in commit message). Creates descriptive commit messages with timestamp and change summary.",
      "execution_time": "< 1 min",
      "requirements": ["git"],
      "warnings": null,
      "use_case": "Automated backup commits with descriptive timestamps and change metrics"
    },
    {
      "id": 221,
      "command": ["date", "git"],
      "difficulty": 4,
      "rating": 5,
      "category": "version control",
      "tags": ["date", "git", "log", "analysis"],
      "task": "Analyze git commits from specific date range and generate report",
      "solution": "start_date=$(date -d '30 days ago' +%Y-%m-%d); git log --since=\"$start_date\" --pretty=format:'%h %ad %an %s' --date=short | awk '{print $2}' | sort | uniq -c | awk '{printf \"Date: %s, Commits: %d\\n\", $2, $1}'",
      "explanation": "start_date=$(date -d '30 days ago' +%Y-%m-%d) (calculate date 30 days ago) git log --since=\"$start_date\" --pretty=format:'%h %ad %an %s' --date=short (get commits since that date with hash, date, author, subject) | awk '{print $2}' | sort | uniq -c (extract dates, count commits per date) | awk '{printf...} (format output). Git activity analysis with date calculations.",
      "execution_time": "< 1 min",
      "requirements": ["git"],
      "warnings": null,
      "use_case": "Development productivity analysis and team activity reporting"
    },
    {
      "id": 222,
      "command": ["date", "find"],
      "difficulty": 3,
      "rating": 4,
      "category": "file management",
      "tags": ["date", "file cleanup", "age-based"],
      "task": "Find and archive files older than specific date using date calculations",
      "solution": "cutoff_date=$(date -d '90 days ago' +%Y-%m-%d); find /data -type f -not -newermt \"$cutoff_date\" -exec tar -czf \"archive_$(date +%Y%m%d).tar.gz\" {} + && find /data -type f -not -newermt \"$cutoff_date\" -delete",
      "explanation": "cutoff_date=$(date -d '90 days ago' +%Y-%m-%d) (calculate cutoff date) find /data -type f -not -newermt \"$cutoff_date\" (find files not newer than cutoff date) -exec tar -czf \"archive_$(date +%Y%m%d).tar.gz\" {} + (archive old files) && find... -delete (delete archived files). Age-based file management with date calculations.",
      "execution_time": "5+ min",
      "requirements": ["tar"],
      "warnings": "Test find command before adding -delete, archives and removes old files",
      "use_case": "Automated data retention policies and storage management"
    },
    {
      "id": 223,
      "command": ["date", "git"],
      "difficulty": 4,
      "rating": 5,
      "category": "version control",
      "tags": ["date", "git", "branch", "workflow"],
      "task": "Create feature branch with date-based naming and initial commit",
      "solution": "branch_name=\"feature/$(date +%Y%m%d)_$(whoami)_new_feature\"; git checkout -b \"$branch_name\" && echo \"# Feature started on $(date '+%Y-%m-%d %H:%M:%S')\" > FEATURE.md && git add FEATURE.md && git commit -m \"Initialize feature branch: $branch_name\"",
      "explanation": "branch_name=\"feature/$(date +%Y%m%d)_$(whoami)_new_feature\" (create branch name with date and username) git checkout -b \"$branch_name\" (create and switch to branch) echo \"# Feature started on $(date '+%Y-%m-%d %H:%M:%S')\" > FEATURE.md (create feature documentation with timestamp) git add FEATURE.md && git commit -m \"Initialize feature branch: $branch_name\" (commit initial documentation). Standardized feature branch workflow.",
      "execution_time": "< 1 min",
      "requirements": ["git"],
      "warnings": null,
      "use_case": "Standardized development workflow with traceable feature branches"
    },
    {
      "id": 224,
      "command": ["date", "cron"],
      "difficulty": 3,
      "rating": 4,
      "category": "automation",
      "tags": ["date", "cron", "scheduling", "backup"],
      "task": "Create cron job for daily backups with date-based file naming",
      "solution": "echo \"0 2 * * * tar -czf /backup/daily_backup_\\$(date +\\%Y\\%m\\%d).tar.gz /important/data && echo \\\"Backup completed: \\$(date)\\\" >> /var/log/backup.log\" | crontab -",
      "explanation": "echo \"0 2 * * *\" (daily at 2 AM) tar -czf /backup/daily_backup_\\$(date +\\%Y\\%m\\%d).tar.gz (create compressed backup with date in filename, escaping $ and % for cron) /important/data && echo \\\"Backup completed: \\$(date)\\\" >> /var/log/backup.log (log completion with timestamp) | crontab - (install cron job). Automated backup scheduling with date-based naming.",
      "execution_time": "< 1 min",
      "requirements": ["cron", "tar"],
      "warnings": "Ensure backup directory exists and has sufficient space",
      "use_case": "Automated daily backups with organized file naming and logging"
    },
    {
      "id": 225,
      "command": ["date", "git"],
      "difficulty": 5,
      "rating": 5,
      "category": "version control",
      "tags": ["date", "git", "release", "tagging"],
      "task": "Create release tag with version numbering based on date and commit count",
      "solution": "version=\"v$(date +%Y.%m).$(git rev-list --count HEAD)\"; git tag -a \"$version\" -m \"Release $version - $(date '+%Y-%m-%d %H:%M:%S') - $(git log --oneline $(git describe --tags --abbrev=0)..HEAD | wc -l) commits since last tag\" && echo \"Created release: $version\"",
      "explanation": "version=\"v$(date +%Y.%m).$(git rev-list --count HEAD)\" (create version: vYYYY.MM.commit_count) git tag -a \"$version\" -m \"Release $version - $(date '+%Y-%m-%d %H:%M:%S') - $(git log --oneline $(git describe --tags --abbrev=0)..HEAD | wc -l) commits since last tag\" (create annotated tag with detailed message including timestamp and commit count since last tag). Automated semantic versioning with date-based releases.",
      "execution_time": "< 1 min",
      "requirements": ["git"],
      "warnings": null,
      "use_case": "Automated release management with semantic versioning and detailed release notes"
    },
    {
      "id": 226,
      "command": ["date", "awk"],
      "difficulty": 4,
      "rating": 4,
      "category": "data analysis",
      "tags": ["date", "log analysis", "time-based filtering"],
      "task": "Analyze log files for entries within specific time window",
      "solution": "start_time=$(date -d '2 hours ago' '+%H:%M:%S'); end_time=$(date '+%H:%M:%S'); awk -v start=\"$start_time\" -v end=\"$end_time\" '$2 >= start && $2 <= end {print}' /var/log/application.log | wc -l",
      "explanation": "start_time=$(date -d '2 hours ago' '+%H:%M:%S') (calculate start time 2 hours ago) end_time=$(date '+%H:%M:%S') (current time) awk -v start=\"$start_time\" -v end=\"$end_time\" (pass times as awk variables) '$2 >= start && $2 <= end {print}' (filter log entries by time range, assuming time is in 2nd column) | wc -l (count matching entries). Time-based log analysis.",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Performance monitoring and incident analysis within specific time windows"
    },
    {
      "id": 227,
      "command": ["date", "git"],
      "difficulty": 4,
      "rating": 4,
      "category": "version control",
      "tags": ["date", "git", "statistics", "productivity"],
      "task": "Generate development productivity report with date-based metrics",
      "solution": "echo \"Development Report - $(date '+%Y-%m-%d')\"; echo \"Last 7 days:\"; git log --since=\"7 days ago\" --author=\"$(git config user.name)\" --pretty=format:'%ad' --date=short | sort | uniq -c; echo \"Total commits: $(git log --since=\"7 days ago\" --author=\"$(git config user.name)\" --oneline | wc -l)\"",
      "explanation": "echo \"Development Report - $(date '+%Y-%m-%d')\" (report header with current date) git log --since=\"7 days ago\" --author=\"$(git config user.name)\" --pretty=format:'%ad' --date=short (get commit dates for current author in last 7 days) | sort | uniq -c (count commits per day) echo \"Total commits: $(git log --since=\"7 days ago\" --author=\"$(git config user.name)\" --oneline | wc -l)\" (total commit count). Personal productivity analysis.",
      "execution_time": "< 1 min",
      "requirements": ["git"],
      "warnings": null,
      "use_case": "Personal development tracking and productivity analysis for time management"
    },
    {
      "id": 228,
      "command": ["date", "mysql"],
      "difficulty": 4,
      "rating": 4,
      "category": "database",
      "tags": ["date", "database", "backup", "automation"],
      "task": "Create database backup with timestamp and retention management",
      "solution": "backup_date=$(date +%Y%m%d_%H%M%S); mysqldump -u user -p'password' database_name > \"backup_${backup_date}.sql\" && gzip \"backup_${backup_date}.sql\" && find /backup/path -name \"backup_*.sql.gz\" -mtime +7 -delete",
      "explanation": "backup_date=$(date +%Y%m%d_%H%M%S) (create timestamp for backup filename) mysqldump -u user -p'password' database_name > \"backup_${backup_date}.sql\" (create database dump with timestamped filename) && gzip \"backup_${backup_date}.sql\" (compress backup) && find /backup/path -name \"backup_*.sql.gz\" -mtime +7 -delete (clean up backups older than 7 days). Database backup with automated retention.",
      "execution_time": "1-5 min",
      "requirements": ["mysql", "gzip"],
      "warnings": "Store database credentials securely, test restore procedures",
      "use_case": "Automated database backup with retention policies for production systems"
    },
    {
      "id": 229,
      "command": ["date", "git"],
      "difficulty": 5,
      "rating": 5,
      "category": "version control",
      "tags": ["date", "git", "workflow", "automation"],
      "task": "Automated daily standup report from git activity with date filtering",
      "solution": "today=$(date +%Y-%m-%d); yesterday=$(date -d 'yesterday' +%Y-%m-%d); echo \"Daily Standup - $today\"; echo \"Yesterday's work:\"; git log --since=\"$yesterday 00:00\" --until=\"$yesterday 23:59\" --author=\"$(git config user.name)\" --pretty=format:'- %s (%h)'; echo -e \"\\n\\nToday's plan:\"; git branch -r | grep feature | head -3",
      "explanation": "today=$(date +%Y-%m-%d); yesterday=$(date -d 'yesterday' +%Y-%m-%d) (calculate dates) echo \"Daily Standup - $today\" (report header) git log --since=\"$yesterday 00:00\" --until=\"$yesterday 23:59\" --author=\"$(git config user.name)\" --pretty=format:'- %s (%h)' (list yesterday's commits with subject and hash) git branch -r | grep feature | head -3 (show feature branches as today's plan). Automated standup report generation.",
      "execution_time": "< 1 min",
      "requirements": ["git"],
      "warnings": null,
      "use_case": "Agile development workflow automation and team communication enhancement"
    },
    {
      "id": 230,
      "command": ["date", "git", "jq"],
      "difficulty": 5,
      "rating": 5,
      "category": "automation",
      "tags": ["date", "git", "json", "reporting"],
      "task": "Generate comprehensive project status report in JSON format with date analytics",
      "solution": "report_date=$(date -Iseconds); git_stats=$(git log --since=\"30 days ago\" --pretty=format:'%ad,%an,%s' --date=short); echo \"{\\\"report_date\\\": \\\"$report_date\\\", \\\"project\\\": \\\"$(basename $(git rev-parse --show-toplevel))\\\", \\\"period\\\": \\\"last_30_days\\\", \\\"total_commits\\\": $(echo \"$git_stats\" | wc -l), \\\"active_days\\\": $(echo \"$git_stats\" | cut -d',' -f1 | sort -u | wc -l), \\\"contributors\\\": $(echo \"$git_stats\" | cut -d',' -f2 | sort -u | wc -l)}\" | jq '.'",
      "explanation": "report_date=$(date -Iseconds) (ISO 8601 timestamp) git_stats=$(git log --since=\"30 days ago\" --pretty=format:'%ad,%an,%s' --date=short) (get 30-day commit data) echo \"{...}\" (create JSON with project statistics: report date, project name from git root, total commits, active days, contributors) | jq '.' (format JSON). Comprehensive project analytics in structured format.",
      "execution_time": "< 1 min",
      "requirements": ["git", "jq"],
      "warnings": null,
      "use_case": "Project management dashboards and automated reporting for stakeholder communication"
    }
  ]
}