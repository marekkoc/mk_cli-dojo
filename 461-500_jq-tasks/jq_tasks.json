[
  {
    "id": 461,
    "command": ["jq"],
    "difficulty": 1,
    "rating": 2,
    "category": "data analysis",
    "tags": ["json", "basic", "display"],
    "task": "Wyświetl sformatowany JSON z pliku employees.json",
    "solution": "jq '.' employees.json",
    "explanation": "jq '.' (kropka oznacza cały dokument) employees.json (plik wejściowy) - wyświetla sformatowany JSON z kolorowaniem składni",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Szybkie sprawdzenie struktury i formatowania pliku JSON"
  },
  {
    "id": 462,
    "command": ["jq"],
    "difficulty": 1,
    "rating": 2,
    "category": "data analysis",
    "tags": ["json", "field", "extraction"],
    "task": "Wyciągnij nazwę firmy z pliku company.json",
    "solution": "jq '.company_info.name' company.json",
    "explanation": "jq '.company_info.name' (dostęp do zagnieżdżonego pola przez kropkę) company.json - wyciąga wartość konkretnego klucza",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Wyciąganie konkretnych wartości z plików konfiguracyjnych"
  },
  {
    "id": 463,
    "command": ["jq"],
    "difficulty": 1,
    "rating": 2,
    "category": "data analysis",
    "tags": ["json", "array", "length"],
    "task": "Policz ile jest pracowników w pliku employees.json",
    "solution": "jq 'length' employees.json",
    "explanation": "jq 'length' (funkcja length zwraca liczbę elementów w tablicy) employees.json - liczy elementy w głównej tablicy",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Szybkie sprawdzenie rozmiaru kolekcji danych"
  },
  {
    "id": 464,
    "command": ["jq"],
    "difficulty": 1,
    "rating": 2,
    "category": "data analysis",
    "tags": ["json", "array", "first"],
    "task": "Wyświetl pierwszego pracownika z pliku employees.json",
    "solution": "jq '.[0]' employees.json",
    "explanation": "jq '.[0]' (indeks 0 oznacza pierwszy element tablicy) employees.json - wyciąga pierwszy obiekt z tablicy",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Sprawdzenie struktury pierwszego rekordu w zbiorze danych"
  },
  {
    "id": 465,
    "command": ["jq"],
    "difficulty": 1,
    "rating": 2,
    "category": "data analysis",
    "tags": ["json", "field", "all"],
    "task": "Wyświetl wszystkie imiona pracowników z pliku employees.json",
    "solution": "jq '.[].name' employees.json",
    "explanation": "jq '.[]' (iteracja po wszystkich elementach tablicy) .name (wyciąg pola name z każdego obiektu) - wyświetla wartości konkretnego pola dla wszystkich rekordów",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Wyciąganie listy wartości z konkretnego pola"
  },
  {
    "id": 466,
    "command": ["jq"],
    "difficulty": 2,
    "rating": 3,
    "category": "data analysis",
    "tags": ["json", "filter", "condition"],
    "task": "Znajdź wszystkich pracowników z działu IT z pliku employees.json",
    "solution": "jq '.[] | select(.department == \"IT\")' employees.json",
    "explanation": "jq '.[]' (iteracja po elementach) | (pipe przekazuje dane dalej) select(.department == \"IT\") (filtruje obiekty gdzie department równa się IT)",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Filtrowanie rekordów według określonych kryteriów"
  },
  {
    "id": 467,
    "command": ["jq"],
    "difficulty": 2,
    "rating": 3,
    "category": "data analysis",
    "tags": ["json", "filter", "salary"],
    "task": "Znajdź pracowników zarabiających więcej niż 10000 zł",
    "solution": "jq '.[] | select(.salary > 10000)' employees.json",
    "explanation": "jq '.[] | select(.salary > 10000)' (select z warunkiem numerycznym) - filtruje obiekty według wartości liczbowej",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Analiza danych finansowych i progów wartości"
  },
  {
    "id": 468,
    "command": ["jq"],
    "difficulty": 2,
    "rating": 3,
    "category": "data analysis",
    "tags": ["json", "map", "projection"],
    "task": "Stwórz listę zawierającą tylko imiona i emaile pracowników",
    "solution": "jq 'map({name: .name, email: .email})' employees.json",
    "explanation": "jq 'map()' (transformuje każdy element tablicy) {name: .name, email: .email} (tworzy nowy obiekt z wybranymi polami) - projekcja danych",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Tworzenie uproszczonych widoków danych dla raportów"
  },
  {
    "id": 469,
    "command": ["jq"],
    "difficulty": 2,
    "rating": 3,
    "category": "data analysis",
    "tags": ["json", "sort", "salary"],
    "task": "Posortuj pracowników według pensji od najwyższej do najniższej",
    "solution": "jq 'sort_by(.salary) | reverse' employees.json",
    "explanation": "jq 'sort_by(.salary)' (sortuje według pola salary rosnąco) | reverse (odwraca kolejność na malejącą) - sortowanie z odwróceniem",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Analiza rankingowa danych liczbowych"
  },
  {
    "id": 470,
    "command": ["jq"],
    "difficulty": 2,
    "rating": 3,
    "category": "data analysis",
    "tags": ["json", "unique", "departments"],
    "task": "Wyświetl unikalne nazwy działów z pliku employees.json",
    "solution": "jq '[.[].department] | unique' employees.json",
    "explanation": "jq '[.[].department]' (tworzy tablicę wszystkich wartości department) | unique (usuwa duplikaty i sortuje) - wyciąganie unikalnych wartości",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Analiza unikalnych wartości w zbiorze danych"
  },
  {
    "id": 471,
    "command": ["jq"],
    "difficulty": 2,
    "rating": 3,
    "category": "data analysis",
    "tags": ["json", "count", "active"],
    "task": "Policz ile jest aktywnych pracowników",
    "solution": "jq '[.[] | select(.active == true)] | length' employees.json",
    "explanation": "jq '[.[] | select(.active == true)]' (filtruje aktywnych i tworzy tablicę) | length (liczy elementy) - zliczanie z filtrowaniem",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Statystyki kondycjonalne w analizie danych"
  },
  {
    "id": 472,
    "command": ["jq"],
    "difficulty": 3,
    "rating": 4,
    "category": "data analysis",
    "tags": ["json", "aggregate", "average"],
    "task": "Oblicz średnią pensję wszystkich pracowników",
    "solution": "jq '[.[].salary] | add / length' employees.json",
    "explanation": "jq '[.[].salary]' (tworzy tablicę wszystkich pensji) | add (sumuje wartości) / length (dzieli przez liczbę elementów) - obliczanie średniej arytmetycznej",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Podstawowe statystyki opisowe w analizie danych"
  },
  {
    "id": 473,
    "command": ["jq"],
    "difficulty": 3,
    "rating": 4,
    "category": "data analysis",
    "tags": ["json", "group", "department"],
    "task": "Pogrupuj pracowników według działów",
    "solution": "jq 'group_by(.department)' employees.json",
    "explanation": "jq 'group_by(.department)' (grupuje elementy według wartości pola department) - tworzy tablicę tablic zgrupowanych obiektów",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Grupowanie danych do analizy kategorycznej"
  },
  {
    "id": 474,
    "command": ["jq"],
    "difficulty": 3,
    "rating": 4,
    "category": "data analysis",
    "tags": ["json", "nested", "skills"],
    "task": "Wyświetl wszystkie umiejętności wszystkich pracowników jako płaską listę",
    "solution": "jq '[.[].skills[]] | unique' employees.json",
    "explanation": "jq '[.[].skills[]]' (wyciąga wszystkie elementy z tablic skills i tworzy jedną tablicę) | unique (usuwa duplikaty) - spłaszczanie zagnieżdżonych tablic",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Analiza zagnieżdżonych kolekcji danych"
  },
  {
    "id": 475,
    "command": ["jq"],
    "difficulty": 3,
    "rating": 4,
    "category": "data analysis",
    "tags": ["json", "conditional", "age"],
    "task": "Dodaj pole 'age_group' do każdego pracownika (young: <30, middle: 30-40, senior: >40)",
    "solution": "jq 'map(. + {age_group: (if .age < 30 then \"young\" elif .age <= 40 then \"middle\" else \"senior\" end)})' employees.json",
    "explanation": "jq 'map()' (transformuje każdy element) . + {} (dodaje nowe pole do obiektu) if-elif-else (logika warunkowa) - wzbogacanie danych o wyliczone pola",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Tworzenie kategorii i segmentacja danych"
  },
  {
    "id": 476,
    "command": ["jq"],
    "difficulty": 3,
    "rating": 4,
    "category": "data analysis",
    "tags": ["json", "nested", "budget"],
    "task": "Znajdź wszystkich pracowników którzy mają projekty z budżetem > 50000",
    "solution": "jq '.[] | select(.projects[] | select(.budget > 50000))' employees.json",
    "explanation": "jq '.[] | select()' (filtruje pracowników) .projects[] | select(.budget > 50000) (sprawdza czy istnieje projekt o budżecie > 50000) - filtrowanie po zagnieżdżonych warunkach",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Wyszukiwanie rekordów z zagnieżdżonymi kryteriami"
  },
  {
    "id": 477,
    "command": ["jq"],
    "difficulty": 3,
    "rating": 4,
    "category": "data analysis",
    "tags": ["json", "max", "performance"],
    "task": "Znajdź pracownika z najwyższą oceną performance_score",
    "solution": "jq 'max_by(.performance_score)' employees.json",
    "explanation": "jq 'max_by(.performance_score)' (znajduje obiekt o maksymalnej wartości wskazanego pola) - znajdowanie rekordu z maksymalną wartością",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Identyfikacja najlepszych wyników w analizie danych"
  },
  {
    "id": 478,
    "command": ["jq"],
    "difficulty": 3,
    "rating": 4,
    "category": "data analysis",
    "tags": ["json", "contains", "skills"],
    "task": "Znajdź pracowników którzy znają Python",
    "solution": "jq '.[] | select(.skills | contains([\"Python\"]))' employees.json",
    "explanation": "jq '.[] | select()' (filtruje pracowników) .skills | contains([\"Python\"]) (sprawdza czy tablica skills zawiera Python) - wyszukiwanie w tablicach",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Wyszukiwanie kompetencji w zespole"
  },
  {
    "id": 479,
    "command": ["jq"],
    "difficulty": 4,
    "rating": 5,
    "category": "data analysis",
    "tags": ["json", "aggregate", "department", "complex"],
    "task": "Stwórz raport pokazujący średnią pensję w każdym dziale",
    "solution": "jq 'group_by(.department) | map({department: .[0].department, avg_salary: (map(.salary) | add / length), count: length})' employees.json",
    "explanation": "group_by(.department) (grupuje według działu) | map() (transformuje każdą grupę) .[0].department (nazwa działu z pierwszego elementu) map(.salary) | add / length (średnia pensji w grupie) - agregacja grupowa",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Tworzenie raportów analitycznych z agregacjami"
  },
  {
    "id": 480,
    "command": ["jq"],
    "difficulty": 4,
    "rating": 5,
    "category": "data analysis",
    "tags": ["json", "join", "cross-reference"],
    "task": "Porównaj budżety działów z company.json z rzeczywistymi średnimi pensjami z employees.json",
    "solution": "jq -s '.[1].departments as $depts | .[0] | group_by(.department) | map({department: .[0].department, real_avg: (map(.salary) | add / length), planned_avg: $depts[.[0].department].avg_salary})' employees.json company.json",
    "explanation": "-s (slurp - wczytuje pliki do tablicy) .[1].departments as $depts (przypisuje departamenty do zmiennej) .[0] (pierwszy plik) group_by (grupuje) $depts[.[0].department] (odwołanie do zmiennej) - łączenie danych z dwóch plików",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Porównywanie danych z różnych źródeł"
  },
  {
    "id": 481,
    "command": ["jq"],
    "difficulty": 4,
    "rating": 5,
    "category": "data analysis",
    "tags": ["json", "flatten", "projects"],
    "task": "Stwórz płaską listę wszystkich projektów z informacjami o pracownikach",
    "solution": "jq '[.[] as $emp | $emp.projects[] | . + {employee_name: $emp.name, employee_id: $emp.id}]' employees.json",
    "explanation": ".[] as $emp (przypisuje pracownika do zmiennej) $emp.projects[] (iteruje po projektach) . + {} (dodaje pola do obiektu projektu) $emp.name (odwołanie do zmiennej) - spłaszczanie zagnieżdżonych struktur z kontekstem",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Denormalizacja danych do analizy projektów"
  },
  {
    "id": 482,
    "command": ["jq"],
    "difficulty": 4,
    "rating": 5,
    "category": "data analysis",
    "tags": ["json", "statistics", "quartiles"],
    "task": "Oblicz kwartyle (Q1, Q2, Q3) dla pensji pracowników",
    "solution": "jq '[.[].salary] | sort | length as $len | {q1: .[$len/4 | floor], q2: .[$len/2 | floor], q3: .[3*$len/4 | floor], min: .[0], max: .[-1]}' employees.json",
    "explanation": "sort (sortuje pensje) length as $len (zapisuje długość) [$len/4 | floor] (oblicza indeks kwartyla) .[] (dostęp do elementu) - obliczanie kwartyli statystycznych",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Analiza statystyczna rozkładu wynagrodzeń"
  },
  {
    "id": 483,
    "command": ["jq"],
    "difficulty": 4,
    "rating": 5,
    "category": "data analysis",
    "tags": ["json", "pivot", "skills"],
    "task": "Stwórz tabelę przestawną pokazującą ile osób w każdym dziale zna każdą umiejętność",
    "solution": "jq '[.[].skills[]] | unique as $all_skills | group_by(.department) | map({department: .[0].department} + ($all_skills | map({(\"skill_\" + .): (map(select(.skills | contains([.]))) | length)}) | add))' employees.json",
    "explanation": "unique as $all_skills (wszystkie unikalne umiejętności) group_by(.department) (grupowanie po działach) map(select(.skills | contains([.]))) (filtrowanie po umiejętnościach) - tworzenie tabeli przestawnej",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Analiza kompetencji w przekroju organizacyjnym"
  },
  {
    "id": 484,
    "command": ["jq"],
    "difficulty": 2,
    "rating": 3,
    "category": "data analysis",
    "tags": ["json", "keys", "structure"],
    "task": "Wyświetl wszystkie klucze głównego obiektu w company.json",
    "solution": "jq 'keys' company.json",
    "explanation": "jq 'keys' (zwraca posortowaną tablicę wszystkich kluczy obiektu) - eksploracja struktury danych",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Analiza struktury nieznanych plików JSON"
  },
  {
    "id": 485,
    "command": ["jq"],
    "difficulty": 2,
    "rating": 3,
    "category": "data analysis",
    "tags": ["json", "nested", "quarterly"],
    "task": "Wyświetl przychody ze wszystkich kwartałów z company.json",
    "solution": "jq '.quarterly_results[].revenue' company.json",
    "explanation": "jq '.quarterly_results[]' (iteruje po wszystkich kwartałach) .revenue (wyciąga przychód) - dostęp do zagnieżdżonych tablic",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Wyciąganie danych finansowych do analizy trendów"
  },
  {
    "id": 486,
    "command": ["jq"],
    "difficulty": 3,
    "rating": 4,
    "category": "data analysis",
    "tags": ["json", "sum", "total"],
    "task": "Oblicz całkowity roczny przychód z wszystkich kwartałów",
    "solution": "jq '[.quarterly_results[].revenue] | add' company.json",
    "explanation": "[.quarterly_results[].revenue] (tworzy tablicę wszystkich przychodów) | add (sumuje wartości) - agregacja liczbowa",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Obliczanie sum rocznych w analizie finansowej"
  },
  {
    "id": 487,
    "command": ["jq"],
    "difficulty": 3,
    "rating": 4,
    "category": "data analysis",
    "tags": ["json", "filter", "profit"],
    "task": "Znajdź kwartały z zyskiem większym niż 600000",
    "solution": "jq '.quarterly_results[] | select(.profit > 600000)' company.json",
    "explanation": ".quarterly_results[] (iteruje po kwartałach) | select(.profit > 600000) (filtruje według zysku) - filtrowanie z warunkiem liczbowym",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Identyfikacja okresów o wysokiej rentowności"
  },
  {
    "id": 488,
    "command": ["jq"],
    "difficulty": 3,
    "rating": 4,
    "category": "data analysis",
    "tags": ["json", "best", "quarter"],
    "task": "Znajdź kwartał z najwyższym zyskiem",
    "solution": "jq '.quarterly_results | max_by(.profit)' company.json",
    "explanation": ".quarterly_results (tablica kwartałów) | max_by(.profit) (znajduje element o maksymalnym zysku) - znajdowanie rekordu z maksymalną wartością",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Identyfikacja najlepszych okresów biznesowych"
  },
  {
    "id": 489,
    "command": ["jq"],
    "difficulty": 3,
    "rating": 4,
    "category": "data analysis",
    "tags": ["json", "languages", "popular"],
    "task": "Wyświetl języki programowania posortowane według popularności",
    "solution": "jq '.technologies.programming_languages | sort_by(.popularity) | reverse' company.json",
    "explanation": ".technologies.programming_languages (dostęp do zagnieżdżonej tablicy) sort_by(.popularity) (sortuje według popularności) reverse (odwraca na malejącą) - sortowanie zagnieżdżonych obiektów",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Ranking technologii według adopcji"
  },
  {
    "id": 490,
    "command": ["jq"],
    "difficulty": 4,
    "rating": 5,
    "category": "data analysis",
    "tags": ["json", "cloud", "costs"],
    "task": "Oblicz całkowite miesięczne koszty chmury i pokaż procentowy udział każdego providera",
    "solution": "jq '.technologies.cloud_providers | to_entries | map(.value.monthly_cost) | add as $total | .technologies.cloud_providers | to_entries | map({provider: .key, cost: .value.monthly_cost, percentage: ((.value.monthly_cost / $total) * 100 | round)})' company.json",
    "explanation": "to_entries (konwertuje obiekt na tablicę par klucz-wartość) map(.value.monthly_cost) | add as $total (oblicza sumę kosztów) (.value.monthly_cost / $total) * 100 (procent udziału) - przekształcanie obiektów i obliczenia procentowe",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Analiza kosztów infrastruktury chmurowej"
  },
  {
    "id": 491,
    "command": ["jq"],
    "difficulty": 4,
    "rating": 5,
    "category": "data analysis",
    "tags": ["json", "office", "density"],
    "task": "Oblicz gęstość pracowników (pracownicy/m²) dla każdego biura",
    "solution": "jq '.office_locations | map({city: .city, employees: .employees, area: .square_meters, density: (.employees / .square_meters | . * 100 | round | . / 100)})' company.json",
    "explanation": "map() (transformuje każde biuro) (.employees / .square_meters) (oblicza gęstość) . * 100 | round | . / 100 (zaokrągla do 2 miejsc po przecinku) - obliczenia z formatowaniem",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Analiza efektywności wykorzystania przestrzeni biurowej"
  },
  {
    "id": 492,
    "command": ["jq"],
    "difficulty": 2,
    "rating": 3,
    "category": "data analysis",
    "tags": ["json", "certificates", "expiring"],
    "task": "Wyświetl nazwy certyfikatów wygasających w 2024 roku",
    "solution": "jq '.certifications[] | select(.valid_until | contains(\"2024\")) | .name' company.json",
    "explanation": ".certifications[] (iteruje po certyfikatach) select(.valid_until | contains(\"2024\")) (filtruje według roku) .name (wyciąga nazwę) - filtrowanie stringów według wzorca",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Monitoring wygasających certyfikacji i licencji"
  },
  {
    "id": 493,
    "command": ["jq"],
    "difficulty": 3,
    "rating": 4,
    "category": "data analysis",
    "tags": ["json", "partners", "count"],
    "task": "Policz łączną liczbę wszystkich partnerów firmy",
    "solution": "jq '.partnerships | [.technology_partners[], .consulting_partners[], .integration_partners[]] | length' company.json",
    "explanation": ".partnerships (obiekt partnerstw) [.technology_partners[], .consulting_partners[], .integration_partners[]] (łączy wszystkie tablice partnerów) length (liczy elementy) - łączenie wielu tablic",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Analiza sieci partnerskiej firmy"
  },
  {
    "id": 494,
    "command": ["jq"],
    "difficulty": 4,
    "rating": 5,
    "category": "data analysis",
    "tags": ["json", "growth", "trend"],
    "task": "Oblicz trend wzrostu przychodów między kwartałami (wzrost procentowy)",
    "solution": "jq '.quarterly_results | [.[1:][]] as $later | [.[:3][]] as $earlier | [$earlier, $later] | transpose | map({from: .[0].quarter, to: .[1].quarter, growth: ((.[1].revenue - .[0].revenue) / .[0].revenue * 100 | round)})' company.json",
    "explanation": "[.[1:][]] (kwartały od drugiego) [.[:3][]] (pierwsze trzy kwartały) transpose (łączy pary) ((.[1].revenue - .[0].revenue) / .[0].revenue * 100) (oblicza wzrost procentowy) - analiza trendów czasowych",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Analiza dynamiki wzrostu biznesu"
  },
  {
    "id": 495,
    "command": ["jq"],
    "difficulty": 5,
    "rating": 5,
    "category": "data analysis",
    "tags": ["json", "complex", "dashboard"],
    "task": "Stwórz kompleksowy dashboard z kluczowymi metrykami firmy",
    "solution": "jq '{company: .company_info.name, total_employees: .company_info.employees_count, annual_revenue: ([.quarterly_results[].revenue] | add), annual_profit: ([.quarterly_results[].profit] | add), profit_margin: (([.quarterly_results[].profit] | add) / ([.quarterly_results[].revenue] | add) * 100 | round), departments_count: (.departments | keys | length), top_technology: (.technologies.programming_languages | max_by(.popularity) | .name), main_office: (.office_locations[] | select(.type == \"headquarters\") | .city)}' company.json",
    "explanation": "Kompleksowe wyrażenie łączące wiele operacji: sumy, średnie, maksima, filtrowanie i dostęp do zagnieżdżonych struktur - tworzenie dashboardu biznesowego",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Tworzenie executivnych dashboardów z kluczowymi KPI"
  },
  {
    "id": 496,
    "command": ["jq"],
    "difficulty": 3,
    "rating": 4,
    "category": "data analysis",
    "tags": ["json", "framework", "satisfaction"],
    "task": "Znajdź framework z najwyższą satysfakcją użytkowników",
    "solution": "jq '.technologies.frameworks | max_by(.satisfaction)' company.json",
    "explanation": ".technologies.frameworks (dostęp do zagnieżdżonej tablicy) max_by(.satisfaction) (znajduje element o maksymalnej satysfakcji) - znajdowanie maksimum w zagnieżdżonych strukturach",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Analiza satysfakcji z technologii używanych w zespole"
  },
  {
    "id": 497,
    "command": ["jq"],
    "difficulty": 3,
    "rating": 4,
    "category": "data analysis",
    "tags": ["json", "conditional", "branch"],
    "task": "Dodaj pole 'office_size' do każdego biura (small: <1000m², medium: 1000-2000m², large: >2000m²)",
    "solution": "jq '.office_locations | map(. + {office_size: (if .square_meters < 1000 then \"small\" elif .square_meters <= 2000 then \"medium\" else \"large\" end)})' company.json",
    "explanation": "map(. + {}) (dodaje pole do każdego obiektu) if-elif-else (logika warunkowa) - kategoryzacja danych liczbowych",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Segmentacja zasobów według rozmiaru"
  },
  {
    "id": 498,
    "command": ["jq"],
    "difficulty": 4,
    "rating": 5,
    "category": "data analysis",
    "tags": ["json", "variance", "statistics"],
    "task": "Oblicz wariancję przychodów kwartalnych",
    "solution": "jq '.quarterly_results | map(.revenue) as $revenues | ($revenues | add / length) as $mean | ($revenues | map(. - $mean | . * .) | add / length) as $variance | {mean: $mean, variance: $variance, std_dev: ($variance | sqrt | . * 100 | round | . / 100)}' company.json",
    "explanation": "map(.revenue) as $revenues (wyciąga przychody) add / length as $mean (oblicza średnią) map(. - $mean | . * .) (kwadraty odchyleń) sqrt (pierwiastek dla odchylenia standardowego) - zaawansowane obliczenia statystyczne",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Analiza zmienności wyników finansowych"
  },
  {
    "id": 499,
    "command": ["jq"],
    "difficulty": 5,
    "rating": 5,
    "category": "data analysis",
    "tags": ["json", "correlation", "complex"],
    "task": "Znajdź korelację między liczbą nowych pracowników a zyskiem w kwartałach",
    "solution": "jq '.quarterly_results | length as $n | map(.new_employees) as $x | map(.profit) as $y | (($x | add) / $n) as $mean_x | (($y | add) / $n) as $mean_y | ([range($n) | $x[.] * $y[.]] | add) as $sum_xy | ([range($n) | $x[.] * $x[.]] | add) as $sum_x2 | ([range($n) | $y[.] * $y[.]] | add) as $sum_y2 | (($sum_xy - $n * $mean_x * $mean_y) / (($sum_x2 - $n * $mean_x * $mean_x) * ($sum_y2 - $n * $mean_y * $mean_y) | sqrt)) as $correlation | {correlation: ($correlation * 1000 | round | . / 1000), interpretation: (if $correlation > 0.7 then \"strong positive\" elif $correlation > 0.3 then \"moderate positive\" elif $correlation > -0.3 then \"weak\" elif $correlation > -0.7 then \"moderate negative\" else \"strong negative\" end)}' company.json",
    "explanation": "Implementacja wzoru korelacji Pearsona: obliczanie średnich, sum iloczynów, sum kwadratów i finalnego współczynnika korelacji - zaawansowana analiza statystyczna",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Analiza zależności między zmiennymi biznesowymi"
  },
  {
    "id": 500,
    "command": ["jq"],
    "difficulty": 1,
    "rating": 2,
    "category": "data analysis",
    "tags": ["json", "pretty", "compact"],
    "task": "Wyświetl company.json w kompaktowym formacie (bez wcięć)",
    "solution": "jq -c '.' company.json",
    "explanation": "jq -c (compact output - format bez wcięć i przestrzeni) '.' (cały dokument) - formatowanie wyjścia JSON",
    "execution_time": "< 1 min",
    "requirements": ["jq"],
    "warnings": null,
    "use_case": "Minimalizacja rozmiaru JSON do przesyłania przez sieć"
  }
]