{
  "tasks": [
    {
      "id": 386,
      "command": ["for", "cat"],
      "difficulty": 1,
      "rating": 2,
      "category": "file management",
      "tags": ["for-loop", "file-reading", "basic"],
      "task": "Read and display the content of all .txt files in documents/txt/ directory",
      "solution": "for file in documents/txt/*.txt; do echo \"=== $file ===\"; cat \"$file\"; echo; done",
      "explanation": "for file in documents/txt/*.txt (iterate over txt files) do echo \"=== $file ===\" (show filename header) cat \"$file\" (display file content) echo (blank line separator) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Quickly review multiple text files for content analysis or debugging"
    },
    {
      "id": 387,
      "command": ["for", "ls", "du"],
      "difficulty": 2,
      "rating": 3,
      "category": "file management",
      "tags": ["for-loop", "file-size", "disk-usage"],
      "task": "Display the size of each file in the documents/ directory with filename",
      "solution": "for file in documents/*; do if [ -f \"$file\" ]; then du -h \"$file\"; fi; done",
      "explanation": "for file in documents/* (iterate over files in documents) do if [ -f \"$file\" ] (check if it's a regular file) then du -h \"$file\" (show human-readable size) fi done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Disk space analysis and file size monitoring for storage management"
    },
    {
      "id": 388,
      "command": ["for", "chmod"],
      "difficulty": 2,
      "rating": 3,
      "category": "file management",
      "tags": ["for-loop", "permissions", "chmod"],
      "task": "Make all .sh files in scripts/bash/ directory executable",
      "solution": "for script in scripts/bash/*.sh; do chmod +x \"$script\"; echo \"Made executable: $script\"; done",
      "explanation": "for script in scripts/bash/*.sh (iterate over shell scripts) do chmod +x \"$script\" (add execute permission) echo \"Made executable: $script\" (confirm action) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Batch permission management for deployment scripts and automation tools"
    },
    {
      "id": 389,
      "command": ["for", "chown"],
      "difficulty": 3,
      "rating": 3,
      "category": "file management",
      "tags": ["for-loop", "ownership", "chown"],
      "task": "Change ownership of all log files to current user (simulate with echo)",
      "solution": "for logfile in logs/*/*.log; do echo \"chown $(whoami): $logfile\"; done",
      "explanation": "for logfile in logs/*/*.log (iterate over log files in subdirectories) do echo \"chown $(whoami): $logfile\" (simulate ownership change to current user) done. Using echo for safety in exercise environment.",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": "In real scenarios, ensure you have appropriate permissions",
      "use_case": "System administration for log file ownership management"
    },
    {
      "id": 390,
      "command": ["for", "wc"],
      "difficulty": 2,
      "rating": 3,
      "category": "file management",
      "tags": ["for-loop", "line-count", "statistics"],
      "task": "Count lines in each .txt file and show filename with line count",
      "solution": "for file in documents/txt/*.txt; do echo -n \"$file: \"; wc -l < \"$file\"; done",
      "explanation": "for file in documents/txt/*.txt (iterate over text files) do echo -n \"$file: \" (print filename without newline) wc -l < \"$file\" (count lines, redirect input to avoid filename in output) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Document analysis and code metrics for project statistics"
    },
    {
      "id": 391,
      "command": ["for", "mv"],
      "difficulty": 3,
      "rating": 4,
      "category": "file management",
      "tags": ["for-loop", "file-renaming", "batch-operations"],
      "task": "Rename all .txt files in numbered_files/ to add .bak extension",
      "solution": "for file in numbered_files/*.txt; do mv \"$file\" \"${file}.bak\"; echo \"Renamed: $file to ${file}.bak\"; done",
      "explanation": "for file in numbered_files/*.txt (iterate over txt files) do mv \"$file\" \"${file}.bak\" (rename by appending .bak) echo \"Renamed: $file to ${file}.bak\" (confirm action) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": "This modifies files - ensure you have backups",
      "use_case": "Batch file backup operations and bulk renaming tasks"
    },
    {
      "id": 392,
      "command": ["for", "cp"],
      "difficulty": 2,
      "rating": 3,
      "category": "file management",
      "tags": ["for-loop", "file-copying", "backup"],
      "task": "Copy all .csv files from data/csv/ to a backup directory",
      "solution": "mkdir -p backup_csv && for file in data/csv/*.csv; do cp \"$file\" backup_csv/; echo \"Copied: $(basename \"$file\")\"; done",
      "explanation": "mkdir -p backup_csv (create backup directory) && for file in data/csv/*.csv (iterate over CSV files) do cp \"$file\" backup_csv/ (copy to backup) echo \"Copied: $(basename \"$file\")\" (show only filename) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Data backup operations and file archiving processes"
    },
    {
      "id": 393,
      "command": ["for", "find"],
      "difficulty": 3,
      "rating": 4,
      "category": "file management",
      "tags": ["for-loop", "file-search", "nested-operations"],
      "task": "Find and display the path of all empty files in each subdirectory",
      "solution": "for dir in */; do echo \"=== Checking $dir ===\"; find \"$dir\" -type f -empty; done",
      "explanation": "for dir in */ (iterate over directories) do echo \"=== Checking $dir ===\" (show current directory) find \"$dir\" -type f -empty (find empty files in directory) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "System cleanup and identifying incomplete file operations"
    },
    {
      "id": 394,
      "command": ["for", "stat"],
      "difficulty": 3,
      "rating": 4,
      "category": "file management",
      "tags": ["for-loop", "file-metadata", "timestamps"],
      "task": "Show last modification time for all files in config/ directory",
      "solution": "for file in config/*/*.conf; do echo -n \"$(basename \"$file\"): \"; stat -c %y \"$file\"; done",
      "explanation": "for file in config/*/*.conf (iterate over config files) do echo -n \"$(basename \"$file\"): \" (show filename without path) stat -c %y \"$file\" (show modification time) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Configuration management and tracking file changes in deployments"
    },
    {
      "id": 395,
      "command": ["for", "grep"],
      "difficulty": 3,
      "rating": 4,
      "category": "file management",
      "tags": ["for-loop", "text-search", "log-analysis"],
      "task": "Search for ERROR entries in all .log files and show filename with match count",
      "solution": "for logfile in logs/*/*.log; do count=$(grep -c \"ERROR\" \"$logfile\"); echo \"$(basename \"$logfile\"): $count errors\"; done",
      "explanation": "for logfile in logs/*/*.log (iterate over log files) do count=$(grep -c \"ERROR\" \"$logfile\") (count ERROR occurrences) echo \"$(basename \"$logfile\"): $count errors\" (show filename and count) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Log analysis and error monitoring for system health checks"
    },
    {
      "id": 396,
      "command": ["for", "seq"],
      "difficulty": 2,
      "rating": 3,
      "category": "automation",
      "tags": ["for-loop", "sequences", "numbering"],
      "task": "Generate numbered backup directories from 1 to 10",
      "solution": "for i in $(seq 1 10); do mkdir -p \"backup_$i\"; echo \"Created backup_$i\"; done",
      "explanation": "for i in $(seq 1 10) (iterate over sequence 1 to 10) do mkdir -p \"backup_$i\" (create numbered directory) echo \"Created backup_$i\" (confirm creation) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Automated directory creation for backup rotations and batch processing"
    },
    {
      "id": 397,
      "command": ["for", "range"],
      "difficulty": 2,
      "rating": 3,
      "category": "automation",
      "tags": ["for-loop", "ranges", "file-creation"],
      "task": "Create 5 empty test files named test_1.txt through test_5.txt",
      "solution": "for i in {1..5}; do touch \"test_$i.txt\"; echo \"Created test_$i.txt\"; done",
      "explanation": "for i in {1..5} (bash range expansion from 1 to 5) do touch \"test_$i.txt\" (create empty file) echo \"Created test_$i.txt\" (confirm creation) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Test environment setup and template file generation"
    },
    {
      "id": 398,
      "command": ["for", "array"],
      "difficulty": 3,
      "rating": 4,
      "category": "automation",
      "tags": ["for-loop", "arrays", "variables"],
      "task": "Process a list of servers and ping each one (simulate with echo)",
      "solution": "servers=(\"web01\" \"web02\" \"db01\" \"cache01\"); for server in \"${servers[@]}\"; do echo \"Pinging $server...\"; echo \"ping -c 1 $server\"; done",
      "explanation": "servers=(\"web01\" \"web02\" \"db01\" \"cache01\") (define array) for server in \"${servers[@]}\" (iterate over array elements) do echo \"Pinging $server...\" echo \"ping -c 1 $server\" (simulate ping command) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Network monitoring and server health checks in DevOps workflows"
    },
    {
      "id": 399,
      "command": ["for", "if"],
      "difficulty": 3,
      "rating": 4,
      "category": "data processing",
      "tags": ["for-loop", "conditionals", "filtering"],
      "task": "Check each file in mixed_content/ and categorize by type (text, image, video, archive)",
      "solution": "for file in mixed_content/*; do if [[ \"$file\" == *.txt ]]; then echo \"Text: $(basename \"$file\")\"; elif [[ \"$file\" == *.jpg ]] || [[ \"$file\" == *.png ]]; then echo \"Image: $(basename \"$file\")\"; elif [[ \"$file\" == *.mp4 ]]; then echo \"Video: $(basename \"$file\")\"; elif [[ \"$file\" == *.zip ]]; then echo \"Archive: $(basename \"$file\")\"; fi; done",
      "explanation": "for file in mixed_content/* (iterate over files) do if [[ \"$file\" == *.txt ]] (check if text file) then echo \"Text: $(basename \"$file\")\" (categorize) elif [[ conditions for other types ]] (check other extensions) fi done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "File organization and automated content categorization systems"
    },
    {
      "id": 400,
      "command": ["for", "awk"],
      "difficulty": 4,
      "rating": 4,
      "category": "data processing",
      "tags": ["for-loop", "csv", "data-extraction"],
      "task": "Extract and display the name and salary columns from each .csv file in data/csv/",
      "solution": "for csvfile in data/csv/*.csv; do echo \"=== $(basename \"$csvfile\") ===\"; awk -F, 'NR>1 {print $2, $4}' \"$csvfile\"; echo; done",
      "explanation": "for csvfile in data/csv/*.csv (iterate over CSV files) do echo \"=== $(basename \"$csvfile\") ===\" (show filename) awk -F, 'NR>1 {print $2, $4}' \"$csvfile\" (extract columns 2 and 4, skip header) echo (blank line) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Data analysis and report generation from multiple CSV datasets"
    },
    {
      "id": 401,
      "command": ["for", "sed"],
      "difficulty": 4,
      "rating": 5,
      "category": "data processing",
      "tags": ["for-loop", "text-processing", "configuration"],
      "task": "Replace all instances of 'localhost' with 'production-server' in config files",
      "solution": "for config in config/*/*.conf; do sed -i.backup 's/localhost/production-server/g' \"$config\"; echo \"Updated: $(basename \"$config\")\"; done",
      "explanation": "for config in config/*/*.conf (iterate over config files) do sed -i.backup 's/localhost/production-server/g' \"$config\" (replace localhost with production-server, create backup) echo \"Updated: $(basename \"$config\")\" (confirm update) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": "This modifies files - backups are created with .backup extension",
      "use_case": "Configuration deployment and environment-specific updates"
    },
    {
      "id": 402,
      "command": ["for", "while"],
      "difficulty": 4,
      "rating": 5,
      "category": "automation",
      "tags": ["for-loop", "nested-loops", "advanced"],
      "task": "Create a multiplication table from 1x1 to 5x5 using nested loops",
      "solution": "for i in {1..5}; do for j in {1..5}; do result=$((i * j)); printf \"%d x %d = %-2d  \" $i $j $result; done; echo; done",
      "explanation": "for i in {1..5} (outer loop 1-5) do for j in {1..5} (inner loop 1-5) do result=$((i * j)) (calculate product) printf \"%d x %d = %-2d  \" $i $j $result (formatted output) done echo (new line after each row) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Mathematical calculations and formatted report generation"
    },
    {
      "id": 403,
      "command": ["for", "date"],
      "difficulty": 3,
      "rating": 4,
      "category": "automation",
      "tags": ["for-loop", "dates", "logging"],
      "task": "Generate log file names for the past 7 days in YYYY-MM-DD format",
      "solution": "for i in {0..6}; do date -d \"$i days ago\" +\"log_%Y-%m-%d.txt\"; done",
      "explanation": "for i in {0..6} (iterate 0 to 6 days) do date -d \"$i days ago\" (calculate date i days back) +\"log_%Y-%m-%d.txt\" (format as log filename) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Log rotation management and automated backup scheduling"
    },
    {
      "id": 404,
      "command": ["for", "tar"],
      "difficulty": 4,
      "rating": 4,
      "category": "automation",
      "tags": ["for-loop", "archiving", "backup"],
      "task": "Create compressed archives for each directory in the current folder",
      "solution": "for dir in */; do if [ -d \"$dir\" ]; then tar -czf \"${dir%/}.tar.gz\" \"$dir\"; echo \"Archived: $dir -> ${dir%/}.tar.gz\"; fi; done",
      "explanation": "for dir in */ (iterate over directories) do if [ -d \"$dir\" ] (verify it's a directory) then tar -czf \"${dir%/}.tar.gz\" (create compressed archive, %/ removes trailing slash) \"$dir\" echo \"Archived: $dir -> ${dir%/}.tar.gz\" (confirm) fi done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Automated backup systems and directory archiving for storage optimization"
    },
    {
      "id": 405,
      "command": ["for", "curl"],
      "difficulty": 4,
      "rating": 5,
      "category": "networking",
      "tags": ["for-loop", "api", "monitoring"],
      "task": "Check HTTP status of multiple URLs (simulate with echo)",
      "solution": "urls=(\"https://google.com\" \"https://github.com\" \"https://stackoverflow.com\"); for url in \"${urls[@]}\"; do echo \"Checking $url...\"; echo \"curl -s -o /dev/null -w '%{http_code}' $url\"; done",
      "explanation": "urls=(array of URLs) for url in \"${urls[@]}\" (iterate over URLs) do echo \"Checking $url...\" echo \"curl -s -o /dev/null -w '%{http_code}' $url\" (simulate HTTP status check) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "Website monitoring and API health checks in DevOps pipelines"
    },
    {
      "id": 406,
      "command": ["for", "ps"],
      "difficulty": 3,
      "rating": 4,
      "category": "system admin",
      "tags": ["for-loop", "processes", "monitoring"],
      "task": "Check if specific processes are running (simulate with echo)",
      "solution": "processes=(\"nginx\" \"mysql\" \"redis\" \"apache\"); for proc in \"${processes[@]}\"; do echo \"Checking process: $proc\"; echo \"pgrep $proc > /dev/null && echo '$proc is running' || echo '$proc is not running'\"; done",
      "explanation": "processes=(array of process names) for proc in \"${processes[@]}\" (iterate over processes) do echo \"Checking process: $proc\" echo simulation of pgrep command with conditional output done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": null,
      "use_case": "System monitoring and service health checks for server management"
    },
    {
      "id": 407,
      "command": ["for", "ssh"],
      "difficulty": 4,
      "rating": 5,
      "category": "system admin",
      "tags": ["for-loop", "remote", "deployment"],
      "task": "Deploy application to multiple servers (simulate commands)",
      "solution": "servers=(\"server1.example.com\" \"server2.example.com\" \"server3.example.com\"); for server in \"${servers[@]}\"; do echo \"Deploying to $server...\"; echo \"ssh user@$server 'cd /app && git pull && systemctl restart myapp'\"; echo \"Deployment to $server completed\"; done",
      "explanation": "servers=(array of server hostnames) for server in \"${servers[@]}\" (iterate over servers) do echo deployment commands including ssh, git pull, and service restart simulation done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": "In real scenarios, ensure SSH keys are properly configured",
      "use_case": "Automated deployment across multiple servers in production environments"
    },
    {
      "id": 408,
      "command": ["for", "docker"],
      "difficulty": 4,
      "rating": 5,
      "category": "containerization",
      "tags": ["for-loop", "docker", "containers"],
      "task": "Stop and remove multiple Docker containers (simulate with echo)",
      "solution": "containers=(\"web-app\" \"database\" \"cache\" \"worker\"); for container in \"${containers[@]}\"; do echo \"Stopping container: $container\"; echo \"docker stop $container\"; echo \"docker rm $container\"; echo \"Container $container removed\"; done",
      "explanation": "containers=(array of container names) for container in \"${containers[@]}\" (iterate over containers) do echo simulation of docker stop and docker rm commands for each container done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": "In real scenarios, ensure containers can be safely stopped",
      "use_case": "Container lifecycle management and cleanup operations in Docker environments"
    },
    {
      "id": 409,
      "command": ["for", "git"],
      "difficulty": 4,
      "rating": 5,
      "category": "development",
      "tags": ["for-loop", "git", "version-control"],
      "task": "Update multiple Git repositories in subdirectories (simulate with echo)",
      "solution": "for dir in */; do if [ -d \"$dir/.git\" ]; then echo \"Updating repository: $dir\"; echo \"cd $dir && git fetch && git pull origin main\"; echo \"Repository $dir updated\"; fi; done",
      "explanation": "for dir in */ (iterate over directories) do if [ -d \"$dir/.git\" ] (check if it's a git repository) then echo simulation of cd, git fetch, and git pull commands fi done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": "In real scenarios, check for uncommitted changes first",
      "use_case": "Bulk repository updates and synchronization in development workflows"
    },
    {
      "id": 410,
      "command": ["for", "cron"],
      "difficulty": 5,
      "rating": 5,
      "category": "automation",
      "tags": ["for-loop", "cron", "scheduling", "advanced"],
      "task": "Generate cron job entries for daily backups of multiple databases at different times",
      "solution": "databases=(\"userdb\" \"orderdb\" \"logdb\" \"analyticsdb\"); hour=2; for db in \"${databases[@]}\"; do echo \"$hour 0 * * * /usr/local/bin/backup_script.sh $db\"; hour=$((hour + 1)); done",
      "explanation": "databases=(array of database names) hour=2 (starting hour) for db in \"${databases[@]}\" (iterate over databases) do echo cron format with incremental hour hour=$((hour + 1)) (increment for next database) done",
      "execution_time": "< 1 min",
      "requirements": null,
      "warnings": "Verify cron syntax and script paths before adding to crontab",
      "use_case": "Automated scheduling system for staggered backup operations and maintenance tasks"
    }
  ]
}